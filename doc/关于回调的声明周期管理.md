# 关于使用回调函数时的绑定对象this指针(指针捕获)的生命周期相关处理
在事件驱动编程时，我们往往需要在事件发生时，根据事件类型的不同，使用if else编写不同的函数调用。然而，在此时我们往往不知道需要调用什么具体的函数，因为这是由用户来自定义的，所以，我们需要将函数变量化后存储在模块中（使用function函数对象），编写一个setCallback方法，来为用户提供设置回调的接口。
用户在调用setCallback来传递自己的函数对象实参时，如果使用std::bind绑定了指针类型，或者使用lamda表达式捕获了指针类型，比方说std::bind(&function,this),那么当事件发生，我们的回调函数每次被调用时，就会访问被绑定对象指针所指向内存数据，如果这个被绑定对象的内存被释放，我们的回调函数再次调用时，就会发生未定行为。所以，我们需要严格化对被绑定对象进行生命周期的控制，务必使其不要在回调正在调用时，或者将会调用时提前析构掉。
我们有如下几种方法：
1. 延长生命周期
2. 使用lamda捕获值
3. 使用weak_ptr检测生命周期（复杂但是安全）
```cpp
class EventCallback:public std::enable_share_from_this<EventCallback>{
private:
    Eventloop*loop_;
    int num_;
    void MyCallback(){
        std::cout<<"enter:num="<<num_<<std::endl;
    }
public:
    EventCallback(Eventloop*loop,int num):loop_(loop),num_(num){
        loop_->setCallback(std::bind(&EventCallback::MyCallback,this));
    }
};
```
在setCallback中，我们使用古老的std::bind来绑定一个裸指针this,这是十分危险的，当this所指向的对象析构掉时，回调函数会访问一个无用内存，这是典型的未定义行为。解决方法是，不直接绑定this裸指针，而是使用现代的lamda+weak_ptr+share_from_this()来解决。
```cpp
class EventCallback:public std::enable_shared_from_this<EventCallback>{ //可以使用share_from_this()在类内部直接获取this的share_ptr版
private:
    Eventloop*loop_;
    int num_;
    void MyCallback(){
        std::cout<<"enter:num="<<num_<<std::endl;
    }
public:
    EventCallback(Eventloop*loop,int num):loop_(loop),num_(num){
        std::weak_ptr<EventCallback>weak_this=share_from_this();
        loop_->setCallback([weak_this](){
            if(auto self=weak_this.lock()){
                self->MyCallback();
            }
        })
    }
};
```
# 关于weak_ptr
